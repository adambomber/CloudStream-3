Index: app/src/main/java/com/lagradost/cloudstream3/MainAPI.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.lagradost.cloudstream3\r\n\r\nimport android.annotation.SuppressLint\r\nimport android.content.Context\r\nimport android.net.Uri\r\nimport android.util.Base64.encodeToString\r\nimport androidx.annotation.WorkerThread\r\nimport androidx.preference.PreferenceManager\r\nimport com.fasterxml.jackson.annotation.JsonProperty\r\nimport com.fasterxml.jackson.databind.DeserializationFeature\r\nimport com.fasterxml.jackson.databind.json.JsonMapper\r\nimport com.fasterxml.jackson.module.kotlin.KotlinModule\r\nimport com.lagradost.cloudstream3.animeproviders.*\r\nimport com.lagradost.cloudstream3.metaproviders.CrossTmdbProvider\r\nimport com.lagradost.cloudstream3.movieproviders.*\r\nimport com.lagradost.cloudstream3.mvvm.logError\r\nimport com.lagradost.cloudstream3.syncproviders.OAuth2API.Companion.aniListApi\r\nimport com.lagradost.cloudstream3.syncproviders.OAuth2API.Companion.malApi\r\nimport com.lagradost.cloudstream3.ui.player.SubtitleData\r\nimport com.lagradost.cloudstream3.utils.AppUtils.toJson\r\nimport com.lagradost.cloudstream3.utils.ExtractorLink\r\nimport okhttp3.Interceptor\r\nimport java.text.SimpleDateFormat\r\nimport java.util.*\r\nimport kotlin.math.absoluteValue\r\n\r\nconst val USER_AGENT =\r\n    \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36\"\r\n\r\n//val baseHeader = mapOf(\"User-Agent\" to USER_AGENT)\r\nval mapper = JsonMapper.builder().addModule(KotlinModule())\r\n    .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false).build()!!\r\n\r\nobject APIHolder {\r\n    val unixTime: Long\r\n        get() = System.currentTimeMillis() / 1000L\r\n    val unixTimeMS: Long\r\n        get() = System.currentTimeMillis()\r\n\r\n    private const val defProvider = 0\r\n\r\n    val allProviders by lazy {\r\n        arrayListOf(\r\n            // Movie providers\r\n            PelisplusProvider(),\r\n            PelisplusHDProvider(),\r\n            PeliSmartProvider(),\r\n            MeloMovieProvider(), // Captcha for links\r\n            DoramasYTProvider(),\r\n            CinecalidadProvider(),\r\n            CuevanaProvider(),\r\n            EntrepeliculasyseriesProvider(),\r\n            PelisflixProvider(),\r\n            SeriesflixProvider(),\r\n            IHaveNoTvProvider(), // Documentaries provider\r\n            LookMovieProvider(), // RECAPTCHA (Please allow up to 5 seconds...)\r\n            VMoveeProvider(),\r\n            AllMoviesForYouProvider(),\r\n            VidEmbedProvider(),\r\n            VfFilmProvider(),\r\n            VfSerieProvider(),\r\n            FrenchStreamProvider(),\r\n            AsianLoadProvider(),\r\n            AsiaFlixProvider(), // restricted\r\n            BflixProvider(),\r\n            FmoviesToProvider(),\r\n            SflixProProvider(),\r\n            FilmanProvider(),\r\n            SflixProvider(),\r\n            DopeboxProvider(),\r\n            SolarmovieProvider(),\r\n            PinoyMoviePediaProvider(),\r\n            PinoyHDXyzProvider(),\r\n            PinoyMoviesEsProvider(),\r\n            TrailersTwoProvider(),\r\n            TwoEmbedProvider(),\r\n            DramaSeeProvider(),\r\n            WatchAsianProvider(),\r\n\t        DramaidProvider(),\r\n            KdramaHoodProvider(),\r\n            AkwamProvider(),\r\n            MyCimaProvider(),\r\n            EgyBestProvider(),\r\n            FaselHDProvider(),\r\n            SoaptwoDayProvider(),\r\n            HDMProvider(),// disabled due to cloudflare\r\n            TheFlixToProvider(),\r\n            StreamingcommunityProvider(),\r\n            TantifilmProvider(),\r\n            HDMovie5(),\r\n            RebahinProvider(),\r\n            LayarKacaProvider(),\r\n\r\n            // Metadata providers\r\n            //TmdbProvider(),\r\n            CrossTmdbProvider(),\r\n            ApiMDBProvider(),\r\n\r\n            // Anime providers\r\n            WatchCartoonOnlineProvider(),\r\n            GogoanimeProvider(),\r\n            AllAnimeProvider(),\r\n            AnimekisaProvider(),\r\n            //ShiroProvider(), // v2 fucked me\r\n            AnimeFlickProvider(),\r\n            AnimeflvnetProvider(),\r\n            TenshiProvider(),\r\n            WcoProvider(),\r\n            AnimePaheProvider(),\r\n            DreamSubProvider(),\r\n            NineAnimeProvider(),\r\n            AnimeWorldProvider(),\r\n            ZoroProvider(),\r\n            DubbedAnimeProvider(),\r\n            MonoschinosProvider(),\r\n            KawaiifuProvider(), // disabled due to cloudflare\r\n\t        NeonimeProvider(),\r\n            KuramanimeProvider(),\r\n            OploverzProvider(),\r\n            GomunimeProvider(),\r\n            NontonAnimeIDProvider(),\r\n            KuronimeProvider(),\r\n            //MultiAnimeProvider(),\r\n\t        NginxProvider(),\r\n            OlgplyProvider(),\r\n        )\r\n    }\r\n\r\n    var apis: List<MainAPI> = arrayListOf()\r\n    private var apiMap: Map<String, Int>? = null\r\n\r\n    private fun initMap() {\r\n        if (apiMap == null)\r\n            apiMap = apis.mapIndexed { index, api -> api.name to index }.toMap()\r\n    }\r\n\r\n    fun getApiFromName(apiName: String?): MainAPI {\r\n        return getApiFromNameNull(apiName) ?: apis[defProvider]\r\n    }\r\n\r\n    fun getApiFromNameNull(apiName: String?): MainAPI? {\r\n        if (apiName == null) return null\r\n        initMap()\r\n\r\n        return apiMap?.get(apiName)?.let { apis.getOrNull(it) }\r\n    }\r\n\r\n    fun getApiFromUrlNull(url: String?): MainAPI? {\r\n        if (url == null) return null\r\n        for (api in allProviders) {\r\n            if (url.startsWith(api.mainUrl))\r\n                return api\r\n        }\r\n        return null\r\n    }\r\n\r\n    fun getLoadResponseIdFromUrl(url : String, apiName: String) : Int {\r\n        return url.replace(getApiFromName(apiName).mainUrl, \"\").replace(\"/\", \"\").hashCode()\r\n    }\r\n\r\n    fun LoadResponse.getId(): Int {\r\n        return getLoadResponseIdFromUrl(url,apiName)\r\n    }\r\n\r\n    /**\r\n     * Gets the website captcha token\r\n     * discovered originally by https://github.com/ahmedgamal17\r\n     * optimized by https://github.com/justfoolingaround\r\n     *\r\n     * @param url the main url, likely the same website you found the key from.\r\n     * @param key used to fill https://www.google.com/recaptcha/api.js?render=....\r\n     *\r\n     * @param referer the referer for the google.com/recaptcha/api.js... request, optional.\r\n     * */\r\n\r\n    // Try document.select(\"script[src*=https://www.google.com/recaptcha/api.js?render=]\").attr(\"src\").substringAfter(\"render=\")\r\n    // To get the key\r\n    suspend fun getCaptchaToken(url: String, key: String, referer: String? = null): String? {\r\n        val uri = Uri.parse(url)\r\n        val domain = encodeToString(\r\n            (uri.scheme + \"://\" + uri.host + \":443\").encodeToByteArray(),\r\n            0\r\n        ).replace(\"\\n\", \"\").replace(\"=\", \".\")\r\n\r\n        val vToken =\r\n            app.get(\r\n                \"https://www.google.com/recaptcha/api.js?render=$key\",\r\n                referer = referer,\r\n                cacheTime = 0\r\n            )\r\n                .text\r\n                .substringAfter(\"releases/\")\r\n                .substringBefore(\"/\")\r\n        val recapToken =\r\n            app.get(\"https://www.google.com/recaptcha/api2/anchor?ar=1&hl=en&size=invisible&cb=cs3&k=$key&co=$domain&v=$vToken\")\r\n                .document\r\n                .selectFirst(\"#recaptcha-token\")?.attr(\"value\")\r\n        if (recapToken != null) {\r\n            return app.post(\r\n                \"https://www.google.com/recaptcha/api2/reload?k=$key\",\r\n                data = mapOf(\r\n                    \"v\" to vToken,\r\n                    \"k\" to key,\r\n                    \"c\" to recapToken,\r\n                    \"co\" to domain,\r\n                    \"sa\" to \"\",\r\n                    \"reason\" to \"q\"\r\n                ), cacheTime = 0\r\n            ).text\r\n                .substringAfter(\"rresp\\\",\\\"\")\r\n                .substringBefore(\"\\\"\")\r\n        }\r\n        return null\r\n    }\r\n\r\n    fun Context.getApiSettings(): HashSet<String> {\r\n        //val settingsManager = PreferenceManager.getDefaultSharedPreferences(this)\r\n\r\n        val hashSet = HashSet<String>()\r\n        val activeLangs = getApiProviderLangSettings()\r\n        hashSet.addAll(apis.filter { activeLangs.contains(it.lang) }.map { it.name })\r\n\r\n        /*val set = settingsManager.getStringSet(\r\n            this.getString(R.string.search_providers_list_key),\r\n            hashSet\r\n        )?.toHashSet() ?: hashSet\r\n\r\n        val list = HashSet<String>()\r\n        for (name in set) {\r\n            val api = getApiFromNameNull(name) ?: continue\r\n            if (activeLangs.contains(api.lang)) {\r\n                list.add(name)\r\n            }\r\n        }*/\r\n        //if (list.isEmpty()) return hashSet\r\n        //return list\r\n        return hashSet\r\n    }\r\n\r\n    fun Context.getApiDubstatusSettings(): HashSet<DubStatus> {\r\n        val settingsManager = PreferenceManager.getDefaultSharedPreferences(this)\r\n        val hashSet = HashSet<DubStatus>()\r\n        hashSet.addAll(DubStatus.values())\r\n        val list = settingsManager.getStringSet(\r\n            this.getString(R.string.display_sub_key),\r\n            hashSet.map { it.name }.toMutableSet()\r\n        ) ?: return hashSet\r\n\r\n        val names = DubStatus.values().map { it.name }.toHashSet()\r\n        //if(realSet.isEmpty()) return hashSet\r\n\r\n        return list.filter { names.contains(it) }.map { DubStatus.valueOf(it) }.toHashSet()\r\n    }\r\n\r\n    fun Context.getApiProviderLangSettings(): HashSet<String> {\r\n        val settingsManager = PreferenceManager.getDefaultSharedPreferences(this)\r\n        val hashSet = HashSet<String>()\r\n        hashSet.add(\"en\") // def is only en\r\n        val list = settingsManager.getStringSet(\r\n            this.getString(R.string.provider_lang_key),\r\n            hashSet.toMutableSet()\r\n        )\r\n\r\n        if (list.isNullOrEmpty()) return hashSet\r\n        return list.toHashSet()\r\n    }\r\n\r\n    fun Context.getApiTypeSettings(): HashSet<TvType> {\r\n        val settingsManager = PreferenceManager.getDefaultSharedPreferences(this)\r\n        val hashSet = HashSet<TvType>()\r\n        hashSet.addAll(TvType.values())\r\n        val list = settingsManager.getStringSet(\r\n            this.getString(R.string.search_types_list_key),\r\n            hashSet.map { it.name }.toMutableSet()\r\n        )\r\n\r\n        if (list.isNullOrEmpty()) return hashSet\r\n\r\n        val names = TvType.values().map { it.name }.toHashSet()\r\n        val realSet = list.filter { names.contains(it) }.map { TvType.valueOf(it) }.toHashSet()\r\n        if (realSet.isEmpty()) return hashSet\r\n\r\n        return realSet\r\n    }\r\n\r\n    fun Context.filterProviderByPreferredMedia(hasHomePageIsRequired: Boolean = true): List<MainAPI> {\r\n        val settingsManager = PreferenceManager.getDefaultSharedPreferences(this)\r\n        val currentPrefMedia =\r\n            settingsManager.getInt(this.getString(R.string.prefer_media_type_key), 0)\r\n        val langs = this.getApiProviderLangSettings()\r\n        val allApis = apis.filter { langs.contains(it.lang) }\r\n            .filter { api -> api.hasMainPage || !hasHomePageIsRequired }\r\n        return if (currentPrefMedia < 1) {\r\n            allApis\r\n        } else {\r\n            // Filter API depending on preferred media type\r\n            val listEnumAnime = listOf(TvType.Anime, TvType.AnimeMovie, TvType.OVA)\r\n            val listEnumMovieTv =\r\n                listOf(TvType.Movie, TvType.TvSeries, TvType.Cartoon, TvType.AsianDrama)\r\n            val listEnumDoc = listOf(TvType.Documentary)\r\n            val mediaTypeList = when (currentPrefMedia) {\r\n                2 -> listEnumAnime\r\n                3 -> listEnumDoc\r\n                else -> listEnumMovieTv\r\n            }\r\n            allApis.filter { api -> api.supportedTypes.any { it in mediaTypeList } }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/*\r\n0 = Site not good\r\n1 = All good\r\n2 = Slow, heavy traffic\r\n3 = restricted, must donate 30 benenes to use\r\n */\r\nconst val PROVIDER_STATUS_KEY = \"PROVIDER_STATUS_KEY\"\r\nconst val PROVIDER_STATUS_URL =\r\n    \"https://raw.githubusercontent.com/LagradOst/CloudStream-3/master/docs/providers.json\"\r\nconst val PROVIDER_STATUS_BETA_ONLY = 3\r\nconst val PROVIDER_STATUS_SLOW = 2\r\nconst val PROVIDER_STATUS_OK = 1\r\nconst val PROVIDER_STATUS_DOWN = 0\r\n\r\ndata class ProvidersInfoJson(\r\n    @JsonProperty(\"name\") var name: String,\r\n    @JsonProperty(\"url\") var url: String,\r\n    @JsonProperty(\"credentials\") var credentials: String? = null,\r\n    @JsonProperty(\"status\") var status: Int,\r\n)\r\n\r\n/**Every provider will **not** have try catch built in, so handle exceptions when calling these functions*/\r\nabstract class MainAPI {\r\n    companion object {\r\n        var overrideData: HashMap<String, ProvidersInfoJson>? = null\r\n    }\r\n\r\n    fun overrideWithNewData(data: ProvidersInfoJson) {\r\n        this.name = data.name\r\n        this.mainUrl = data.url\r\n\t    this.storedCredentials = data.credentials\r\n    }\r\n\r\n    init {\r\n        overrideData?.get(this.javaClass.simpleName)?.let { data ->\r\n            overrideWithNewData(data)\r\n        }\r\n    }\r\n\r\n    open var name = \"NONE\"\r\n    open var mainUrl = \"NONE\"\r\n    open var storedCredentials: String? = null\r\n\r\n    //open val uniqueId : Int by lazy { this.name.hashCode() } // in case of duplicate providers you can have a shared id\r\n\r\n    open val lang = \"en\" // ISO_639_1 check SubtitleHelper\r\n\r\n    /**If link is stored in the \"data\" string, so links can be instantly loaded*/\r\n    open val instantLinkLoading = false\r\n\r\n    /**Set false if links require referer or for some reason cant be played on a chromecast*/\r\n    open val hasChromecastSupport = true\r\n\r\n    /**If all links are encrypted then set this to false*/\r\n    open val hasDownloadSupport = true\r\n\r\n    /**Used for testing and can be used to disable the providers if WebView is not available*/\r\n    open val usesWebView = false\r\n\r\n    open val hasMainPage = false\r\n    open val hasQuickSearch = false\r\n\r\n    open val supportedTypes = setOf(\r\n        TvType.Movie,\r\n        TvType.TvSeries,\r\n        TvType.Cartoon,\r\n        TvType.Anime,\r\n        TvType.OVA,\r\n    )\r\n\r\n    open val vpnStatus = VPNStatus.None\r\n    open val providerType = ProviderType.DirectProvider\r\n\r\n    @WorkerThread\r\n    open suspend fun getMainPage(): HomePageResponse? {\r\n        throw NotImplementedError()\r\n    }\r\n\r\n    @WorkerThread\r\n    open suspend fun search(query: String): List<SearchResponse>? {\r\n        throw NotImplementedError()\r\n    }\r\n\r\n    @WorkerThread\r\n    open suspend fun quickSearch(query: String): List<SearchResponse>? {\r\n        throw NotImplementedError()\r\n    }\r\n\r\n    @WorkerThread\r\n    /**\r\n     * Based on data from search() or getMainPage() it generates a LoadResponse,\r\n     * basically opening the info page from a link.\r\n     * */\r\n    open suspend fun load(url: String): LoadResponse? {\r\n        throw NotImplementedError()\r\n    }\r\n\r\n    /**\r\n     * Largely redundant feature for most providers.\r\n     *\r\n     * This job runs in the background when a link is playing in exoplayer.\r\n     * First implemented to do polling for sflix to keep the link from getting expired.\r\n     *\r\n     * This function might be updated to include exoplayer timestamps etc in the future\r\n     * if the need arises.\r\n     * */\r\n    @WorkerThread\r\n    open suspend fun extractorVerifierJob(extractorData: String?) {\r\n        throw NotImplementedError()\r\n    }\r\n\r\n    /**Callback is fired once a link is found, will return true if method is executed successfully*/\r\n    @WorkerThread\r\n    open suspend fun loadLinks(\r\n        data: String,\r\n        isCasting: Boolean,\r\n        subtitleCallback: (SubtitleFile) -> Unit,\r\n        callback: (ExtractorLink) -> Unit\r\n    ): Boolean {\r\n        throw NotImplementedError()\r\n    }\r\n\r\n    /** An okhttp interceptor for used in OkHttpDataSource */\r\n    open fun getVideoInterceptor(extractorLink: ExtractorLink): Interceptor? {\r\n        return null\r\n    }\r\n}\r\n\r\n/** Might need a different implementation for desktop*/\r\n@SuppressLint(\"NewApi\")\r\nfun base64Decode(string: String): String {\r\n    return String(base64DecodeArray(string), Charsets.ISO_8859_1)\r\n}\r\n\r\n@SuppressLint(\"NewApi\")\r\nfun base64DecodeArray(string: String): ByteArray {\r\n    return try {\r\n        android.util.Base64.decode(string, android.util.Base64.DEFAULT)\r\n    } catch (e: Exception) {\r\n        Base64.getDecoder().decode(string)\r\n    }\r\n}\r\n\r\n@SuppressLint(\"NewApi\")\r\nfun base64Encode(array: ByteArray): String {\r\n    return try {\r\n        String(android.util.Base64.encode(array, android.util.Base64.NO_WRAP), Charsets.ISO_8859_1)\r\n    } catch (e: Exception) {\r\n        String(Base64.getEncoder().encode(array))\r\n    }\r\n}\r\n\r\nclass ErrorLoadingException(message: String? = null) : Exception(message)\r\n\r\nfun parseRating(ratingString: String?): Int? {\r\n    if (ratingString == null) return null\r\n    val floatRating = ratingString.toFloatOrNull() ?: return null\r\n    return (floatRating * 10).toInt()\r\n}\r\n\r\nfun MainAPI.fixUrlNull(url: String?): String? {\r\n    if (url.isNullOrEmpty()) {\r\n        return null\r\n    }\r\n    return fixUrl(url)\r\n}\r\n\r\nfun MainAPI.fixUrl(url: String): String {\r\n    if (url.startsWith(\"http\")) {\r\n        return url\r\n    }\r\n    if (url.isEmpty()) {\r\n        return \"\"\r\n    }\r\n\r\n    val startsWithNoHttp = url.startsWith(\"//\")\r\n    if (startsWithNoHttp) {\r\n        return \"https:$url\"\r\n    } else {\r\n        if (url.startsWith('/')) {\r\n            return mainUrl + url\r\n        }\r\n        return \"$mainUrl/$url\"\r\n    }\r\n}\r\n\r\nfun sortUrls(urls: Set<ExtractorLink>): List<ExtractorLink> {\r\n    return urls.sortedBy { t -> -t.quality }\r\n}\r\n\r\nfun sortSubs(subs: Set<SubtitleData>): List<SubtitleData> {\r\n    return subs.sortedBy { it.name }\r\n}\r\n\r\nfun capitalizeString(str: String): String {\r\n    return capitalizeStringNullable(str) ?: str\r\n}\r\n\r\nfun capitalizeStringNullable(str: String?): String? {\r\n    if (str == null)\r\n        return null\r\n    return try {\r\n        str.replaceFirstChar { if (it.isLowerCase()) it.titlecase(Locale.getDefault()) else it.toString() }\r\n    } catch (e: Exception) {\r\n        str\r\n    }\r\n}\r\n\r\n/** https://www.imdb.com/title/tt2861424/ -> tt2861424 */\r\nfun imdbUrlToId(url: String): String? {\r\n    return Regex(\"/title/(tt[0-9]*)\").find(url)?.groupValues?.get(1)\r\n        ?: Regex(\"tt[0-9]{5,}\").find(url)?.groupValues?.get(0)\r\n}\r\n\r\nfun imdbUrlToIdNullable(url: String?): String? {\r\n    if (url == null) return null\r\n    return imdbUrlToId(url)\r\n}\r\n\r\nenum class ProviderType {\r\n    // When data is fetched from a 3rd party site like imdb\r\n    MetaProvider,\r\n\r\n    // When all data is from the site\r\n    DirectProvider,\r\n}\r\n\r\nenum class VPNStatus {\r\n    None,\r\n    MightBeNeeded,\r\n    Torrent,\r\n}\r\n\r\nenum class ShowStatus {\r\n    Completed,\r\n    Ongoing,\r\n}\r\n\r\nenum class DubStatus(val id: Int) {\r\n    Dubbed(1),\r\n    Subbed(0),\r\n}\r\n\r\nenum class TvType {\r\n    Movie,\r\n    AnimeMovie,\r\n    TvSeries,\r\n    Cartoon,\r\n    Anime,\r\n    OVA,\r\n    Torrent,\r\n    Documentary,\r\n    AsianDrama,\r\n}\r\n\r\n// IN CASE OF FUTURE ANIME MOVIE OR SMTH\r\nfun TvType.isMovieType(): Boolean {\r\n    return this == TvType.Movie || this == TvType.AnimeMovie || this == TvType.Torrent\r\n}\r\n\r\n// returns if the type has an anime opening\r\nfun TvType.isAnimeOp(): Boolean {\r\n    return this == TvType.Anime || this == TvType.OVA\r\n}\r\n\r\ndata class SubtitleFile(val lang: String, val url: String)\r\n\r\nclass HomePageResponse(\r\n    val items: List<HomePageList>\r\n)\r\n\r\nclass HomePageList(\r\n    val name: String,\r\n    var list: List<SearchResponse>\r\n)\r\n\r\nenum class SearchQuality {\r\n    //https://en.wikipedia.org/wiki/Pirated_movie_release_types\r\n    Cam,\r\n    CamRip,\r\n    HdCam,\r\n    Telesync, // TS\r\n    WorkPrint,\r\n    Telecine, // TC\r\n    HQ,\r\n    HD,\r\n    HDR, // high dynamic range\r\n    BlueRay,\r\n    DVD,\r\n    SD,\r\n    FourK,\r\n    UHD,\r\n    SDR, // standard dynamic range\r\n    WebRip\r\n}\r\n\r\n/**Add anything to here if you find a site that uses some specific naming convention*/\r\nfun getQualityFromString(string: String?): SearchQuality? {\r\n    val check = (string ?: return null).trim().lowercase().replace(\" \", \"\")\r\n\r\n    return when (check) {\r\n        \"cam\" -> SearchQuality.Cam\r\n        \"camrip\" -> SearchQuality.CamRip\r\n        \"hdcam\" -> SearchQuality.HdCam\r\n        \"hdtc\" -> SearchQuality.HdCam\r\n        \"hdts\" -> SearchQuality.HdCam\r\n        \"highquality\" -> SearchQuality.HQ\r\n        \"hq\" -> SearchQuality.HQ\r\n        \"highdefinition\" -> SearchQuality.HD\r\n        \"hdrip\" -> SearchQuality.HD\r\n        \"hd\" -> SearchQuality.HD\r\n        \"hdtv\" -> SearchQuality.HD\r\n        \"rip\" -> SearchQuality.CamRip\r\n        \"telecine\" -> SearchQuality.Telecine\r\n        \"tc\" -> SearchQuality.Telecine\r\n        \"telesync\" -> SearchQuality.Telesync\r\n        \"ts\" -> SearchQuality.Telesync\r\n        \"dvd\" -> SearchQuality.DVD\r\n        \"dvdrip\" -> SearchQuality.DVD\r\n        \"dvdscr\" -> SearchQuality.DVD\r\n        \"blueray\" -> SearchQuality.BlueRay\r\n        \"bluray\" -> SearchQuality.BlueRay\r\n        \"blu\" -> SearchQuality.BlueRay\r\n        \"fhd\" -> SearchQuality.HD\r\n        \"br\" -> SearchQuality.BlueRay\r\n        \"standard\" -> SearchQuality.SD\r\n        \"sd\" -> SearchQuality.SD\r\n        \"4k\" -> SearchQuality.FourK\r\n        \"uhd\" -> SearchQuality.UHD // may also be 4k or 8k\r\n        \"blue\" -> SearchQuality.BlueRay\r\n        \"wp\" -> SearchQuality.WorkPrint\r\n        \"workprint\" -> SearchQuality.WorkPrint\r\n        \"webrip\" -> SearchQuality.WebRip\r\n        \"webdl\" -> SearchQuality.WebRip\r\n        \"web\" -> SearchQuality.WebRip\r\n        \"hdr\" -> SearchQuality.HDR\r\n        \"sdr\" -> SearchQuality.SDR\r\n        else -> null\r\n    }\r\n}\r\n\r\ninterface SearchResponse {\r\n    val name: String\r\n    val url: String\r\n    val apiName: String\r\n    var type: TvType?\r\n    var posterUrl: String?\r\n    var posterHeaders: Map<String, String>?\r\n    var id: Int?\r\n    var quality: SearchQuality?\r\n}\r\n\r\nfun MainAPI.newMovieSearchResponse(\r\n    name: String,\r\n    url: String,\r\n    type: TvType = TvType.Movie,\r\n    fix: Boolean = true,\r\n    initializer: MovieSearchResponse.() -> Unit = { },\r\n): MovieSearchResponse {\r\n    val builder = MovieSearchResponse(name, if (fix) fixUrl(url) else url, this.name, type)\r\n    builder.initializer()\r\n\r\n    return builder\r\n}\r\n\r\nfun MainAPI.newTvSeriesSearchResponse(\r\n    name: String,\r\n    url: String,\r\n    type: TvType = TvType.TvSeries,\r\n    fix: Boolean = true,\r\n    initializer: TvSeriesSearchResponse.() -> Unit = { },\r\n): TvSeriesSearchResponse {\r\n    val builder = TvSeriesSearchResponse(name, if (fix) fixUrl(url) else url, this.name, type)\r\n    builder.initializer()\r\n\r\n    return builder\r\n}\r\n\r\n\r\nfun MainAPI.newAnimeSearchResponse(\r\n    name: String,\r\n    url: String,\r\n    type: TvType = TvType.Anime,\r\n    fix: Boolean = true,\r\n    initializer: AnimeSearchResponse.() -> Unit = { },\r\n): AnimeSearchResponse {\r\n    val builder = AnimeSearchResponse(name, if (fix) fixUrl(url) else url, this.name, type)\r\n    builder.initializer()\r\n\r\n    return builder\r\n}\r\n\r\nfun SearchResponse.addQuality(quality: String) {\r\n    this.quality = getQualityFromString(quality)\r\n}\r\n\r\nfun SearchResponse.addPoster(url: String?, headers: Map<String, String>? = null) {\r\n    this.posterUrl = url\r\n    this.posterHeaders = headers\r\n}\r\n\r\nfun LoadResponse.addPoster(url: String?, headers: Map<String, String>? = null) {\r\n    this.posterUrl = url\r\n    this.posterHeaders = headers\r\n}\r\n\r\nenum class ActorRole {\r\n    Main,\r\n    Supporting,\r\n    Background,\r\n}\r\n\r\ndata class Actor(\r\n    val name: String,\r\n    val image: String? = null,\r\n)\r\n\r\ndata class ActorData(\r\n    val actor: Actor,\r\n    val role: ActorRole? = null,\r\n    val roleString: String? = null,\r\n    val voiceActor: Actor? = null,\r\n)\r\n\r\ndata class AnimeSearchResponse(\r\n    override val name: String,\r\n    override val url: String,\r\n    override val apiName: String,\r\n    override var type: TvType? = null,\r\n\r\n    override var posterUrl: String? = null,\r\n    var year: Int? = null,\r\n    var dubStatus: EnumSet<DubStatus>? = null,\r\n\r\n    var otherName: String? = null,\r\n    var episodes: MutableMap<DubStatus, Int> = mutableMapOf(),\r\n\r\n    override var id: Int? = null,\r\n    override var quality: SearchQuality? = null,\r\n    override var posterHeaders: Map<String, String>? = null,\r\n) : SearchResponse\r\n\r\nfun AnimeSearchResponse.addDubStatus(status: DubStatus, episodes: Int? = null) {\r\n    this.dubStatus = dubStatus?.also { it.add(status) } ?: EnumSet.of(status)\r\n    if (this.type?.isMovieType() != true)\r\n        if (episodes != null && episodes > 0)\r\n            this.episodes[status] = episodes\r\n}\r\n\r\nfun AnimeSearchResponse.addDubStatus(isDub: Boolean, episodes: Int? = null) {\r\n    addDubStatus(if (isDub) DubStatus.Dubbed else DubStatus.Subbed, episodes)\r\n}\r\n\r\nfun AnimeSearchResponse.addDub(episodes: Int?) {\r\n    if(episodes == null || episodes <= 0) return\r\n    addDubStatus(DubStatus.Dubbed, episodes)\r\n}\r\n\r\nfun AnimeSearchResponse.addSub(episodes: Int?) {\r\n    if(episodes == null || episodes <= 0) return\r\n    addDubStatus(DubStatus.Subbed, episodes)\r\n}\r\n\r\nfun AnimeSearchResponse.addDubStatus(\r\n    dubExist: Boolean,\r\n    subExist: Boolean,\r\n    dubEpisodes: Int? = null,\r\n    subEpisodes: Int? = null\r\n) {\r\n    if (dubExist)\r\n        addDubStatus(DubStatus.Dubbed, dubEpisodes)\r\n\r\n    if (subExist)\r\n        addDubStatus(DubStatus.Subbed, subEpisodes)\r\n}\r\n\r\nfun AnimeSearchResponse.addDubStatus(status: String, episodes: Int? = null) {\r\n    if (status.contains(\"(dub)\", ignoreCase = true)) {\r\n        addDubStatus(DubStatus.Dubbed)\r\n    } else if (status.contains(\"(sub)\", ignoreCase = true)) {\r\n        addDubStatus(DubStatus.Subbed)\r\n    }\r\n}\r\n\r\ndata class TorrentSearchResponse(\r\n    override val name: String,\r\n    override val url: String,\r\n    override val apiName: String,\r\n    override var type: TvType?,\r\n\r\n    override var posterUrl: String?,\r\n    override var id: Int? = null,\r\n    override var quality: SearchQuality? = null,\r\n    override var posterHeaders: Map<String, String>? = null,\r\n) : SearchResponse\r\n\r\ndata class MovieSearchResponse(\r\n    override val name: String,\r\n    override val url: String,\r\n    override val apiName: String,\r\n    override var type: TvType? = null,\r\n\r\n    override var posterUrl: String? = null,\r\n    val year: Int? = null,\r\n    override var id: Int? = null,\r\n    override var quality: SearchQuality? = null,\r\n    override var posterHeaders: Map<String, String>? = null,\r\n) : SearchResponse\r\n\r\ndata class TvSeriesSearchResponse(\r\n    override val name: String,\r\n    override val url: String,\r\n    override val apiName: String,\r\n    override var type: TvType? = null,\r\n\r\n    override var posterUrl: String? = null,\r\n    val year: Int? = null,\r\n    val episodes: Int? = null,\r\n    override var id: Int? = null,\r\n    override var quality: SearchQuality? = null,\r\n    override var posterHeaders: Map<String, String>? = null,\r\n) : SearchResponse\r\n\r\ninterface LoadResponse {\r\n    var name: String\r\n    var url: String\r\n    var apiName: String\r\n    var type: TvType\r\n    var posterUrl: String?\r\n    var year: Int?\r\n    var plot: String?\r\n    var rating: Int? // 1-1000\r\n    var tags: List<String>?\r\n    var duration: Int? // in minutes\r\n    var trailers: List<String>?\r\n    var recommendations: List<SearchResponse>?\r\n    var actors: List<ActorData>?\r\n    var comingSoon: Boolean\r\n    var syncData: MutableMap<String, String>\r\n    var posterHeaders: Map<String, String>?\r\n\r\n    companion object {\r\n        private val malIdPrefix = malApi.idPrefix\r\n        private val aniListIdPrefix = aniListApi.idPrefix\r\n\r\n        @JvmName(\"addActorNames\")\r\n        fun LoadResponse.addActors(actors: List<String>?) {\r\n            this.actors = actors?.map { ActorData(Actor(it)) }\r\n        }\r\n\r\n        @JvmName(\"addActors\")\r\n        fun LoadResponse.addActors(actors: List<Pair<Actor, String?>>?) {\r\n            this.actors = actors?.map { (actor, role) -> ActorData(actor, roleString = role) }\r\n        }\r\n\r\n        @JvmName(\"addActorsRole\")\r\n        fun LoadResponse.addActors(actors: List<Pair<Actor, ActorRole?>>?) {\r\n            this.actors = actors?.map { (actor, role) -> ActorData(actor, role = role) }\r\n        }\r\n\r\n        @JvmName(\"addActorsOnly\")\r\n        fun LoadResponse.addActors(actors: List<Actor>?) {\r\n            this.actors = actors?.map { actor -> ActorData(actor) }\r\n        }\r\n\r\n        fun LoadResponse.addMalId(id: Int?) {\r\n            this.syncData[malIdPrefix] = (id ?: return).toString()\r\n        }\r\n\r\n        fun LoadResponse.addAniListId(id: Int?) {\r\n            this.syncData[aniListIdPrefix] = (id ?: return).toString()\r\n        }\r\n\r\n        fun LoadResponse.addImdbUrl(url: String?) {\r\n            addImdbId(imdbUrlToIdNullable(url))\r\n        }\r\n\r\n        /**better to set trailers directly instead of calling this multiple times*/\r\n        fun LoadResponse.addTrailer(trailerUrl: String?) {\r\n            if (trailerUrl == null) return\r\n            if (this.trailers == null) {\r\n                this.trailers = listOf(trailerUrl)\r\n            } else {\r\n                val update = this.trailers?.toMutableList()\r\n                update?.add(trailerUrl)\r\n                this.trailers = update\r\n            }\r\n        }\r\n\r\n        fun LoadResponse.addImdbId(id: String?) {\r\n            // TODO add imdb sync\r\n        }\r\n\r\n        fun LoadResponse.addTrackId(id: String?) {\r\n            // TODO add trackt sync\r\n        }\r\n\r\n        fun LoadResponse.addkitsuId(id: String?) {\r\n            // TODO add kitsu sync\r\n        }\r\n\r\n        fun LoadResponse.addTMDbId(id: String?) {\r\n            // TODO add TMDb sync\r\n        }\r\n\r\n        fun LoadResponse.addRating(text: String?) {\r\n            addRating(text.toRatingInt())\r\n        }\r\n\r\n        fun LoadResponse.addRating(value: Int?) {\r\n            if (value ?: return < 0 || value > 1000) {\r\n                return\r\n            }\r\n            this.rating = value\r\n        }\r\n\r\n        fun LoadResponse.addDuration(input: String?) {\r\n            val cleanInput = input?.trim()?.replace(\" \", \"\") ?: return\r\n            Regex(\"([0-9]*)h.*?([0-9]*)m\").find(cleanInput)?.groupValues?.let { values ->\r\n                if (values.size == 3) {\r\n                    val hours = values[1].toIntOrNull()\r\n                    val minutes = values[2].toIntOrNull()\r\n                    this.duration = if (minutes != null && hours != null) {\r\n                        hours * 60 + minutes\r\n                    } else null\r\n                    if (this.duration != null) return\r\n                }\r\n            }\r\n            Regex(\"([0-9]*)m\").find(cleanInput)?.groupValues?.let { values ->\r\n                if (values.size == 2) {\r\n                    this.duration = values[1].toIntOrNull()\r\n                    if (this.duration != null) return\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfun LoadResponse?.isEpisodeBased(): Boolean {\r\n    if (this == null) return false\r\n    return (this is AnimeLoadResponse || this is TvSeriesLoadResponse) && this.type.isEpisodeBased()\r\n}\r\n\r\nfun LoadResponse?.isAnimeBased(): Boolean {\r\n    if (this == null) return false\r\n    return (this.type == TvType.Anime || this.type == TvType.OVA) // && (this is AnimeLoadResponse)\r\n}\r\n\r\nfun TvType?.isEpisodeBased(): Boolean {\r\n    if (this == null) return false\r\n    return (this == TvType.TvSeries || this == TvType.Anime)\r\n}\r\n\r\ndata class TorrentLoadResponse(\r\n    override var name: String,\r\n    override var url: String,\r\n    override var apiName: String,\r\n    var magnet: String?,\r\n    var torrent: String?,\r\n    override var plot: String?,\r\n    override var type: TvType = TvType.Torrent,\r\n    override var posterUrl: String? = null,\r\n    override var year: Int? = null,\r\n    override var rating: Int? = null,\r\n    override var tags: List<String>? = null,\r\n    override var duration: Int? = null,\r\n    override var trailers: List<String>? = null,\r\n    override var recommendations: List<SearchResponse>? = null,\r\n    override var actors: List<ActorData>? = null,\r\n    override var comingSoon: Boolean = false,\r\n    override var syncData: MutableMap<String, String> = mutableMapOf(),\r\n    override var posterHeaders: Map<String, String>? = null,\r\n) : LoadResponse\r\n\r\ndata class AnimeLoadResponse(\r\n    var engName: String? = null,\r\n    var japName: String? = null,\r\n    override var name: String,\r\n    override var url: String,\r\n    override var apiName: String,\r\n    override var type: TvType,\r\n\r\n    override var posterUrl: String? = null,\r\n    override var year: Int? = null,\r\n\r\n    var episodes: MutableMap<DubStatus, List<Episode>> = mutableMapOf(),\r\n    var showStatus: ShowStatus? = null,\r\n\r\n    override var plot: String? = null,\r\n    override var tags: List<String>? = null,\r\n    var synonyms: List<String>? = null,\r\n\r\n    override var rating: Int? = null,\r\n    override var duration: Int? = null,\r\n    override var trailers: List<String>? = null,\r\n    override var recommendations: List<SearchResponse>? = null,\r\n    override var actors: List<ActorData>? = null,\r\n    override var comingSoon: Boolean = false,\r\n    override var syncData: MutableMap<String, String> = mutableMapOf(),\r\n    override var posterHeaders: Map<String, String>? = null,\r\n) : LoadResponse\r\n\r\nfun AnimeLoadResponse.addEpisodes(status: DubStatus, episodes: List<Episode>?) {\r\n    if (episodes == null) return\r\n    this.episodes[status] = episodes\r\n}\r\n\r\nfun MainAPI.newAnimeLoadResponse(\r\n    name: String,\r\n    url: String,\r\n    type: TvType,\r\n    comingSoonIfNone: Boolean = true,\r\n    initializer: AnimeLoadResponse.() -> Unit = { },\r\n): AnimeLoadResponse {\r\n    val builder = AnimeLoadResponse(name = name, url = url, apiName = this.name, type = type)\r\n    builder.initializer()\r\n    if (comingSoonIfNone) {\r\n        builder.comingSoon = true\r\n        for (key in builder.episodes.keys)\r\n            if (!builder.episodes[key].isNullOrEmpty()) {\r\n                builder.comingSoon = false\r\n                break\r\n            }\r\n    }\r\n    return builder\r\n}\r\n\r\ndata class MovieLoadResponse(\r\n    override var name: String,\r\n    override var url: String,\r\n    override var apiName: String,\r\n    override var type: TvType,\r\n    var dataUrl: String,\r\n\r\n    override var posterUrl: String? = null,\r\n    override var year: Int? = null,\r\n    override var plot: String? = null,\r\n\r\n    override var rating: Int? = null,\r\n    override var tags: List<String>? = null,\r\n    override var duration: Int? = null,\r\n    override var trailers: List<String>? = null,\r\n    override var recommendations: List<SearchResponse>? = null,\r\n    override var actors: List<ActorData>? = null,\r\n    override var comingSoon: Boolean = false,\r\n    override var syncData: MutableMap<String, String> = mutableMapOf(),\r\n    override var posterHeaders: Map<String, String>? = null,\r\n) : LoadResponse\r\n\r\nfun <T> MainAPI.newMovieLoadResponse(\r\n    name: String,\r\n    url: String,\r\n    type: TvType,\r\n    data: T?,\r\n    initializer: MovieLoadResponse.() -> Unit = { }\r\n): MovieLoadResponse {\r\n    // just in case\r\n    if (data is String) return newMovieLoadResponse(\r\n        name,\r\n        url,\r\n        type,\r\n        dataUrl = data,\r\n        initializer = initializer\r\n    )\r\n    val dataUrl = data?.toJson() ?: \"\"\r\n    val builder = MovieLoadResponse(\r\n        name = name,\r\n        url = url,\r\n        apiName = this.name,\r\n        type = type,\r\n        dataUrl = dataUrl,\r\n        comingSoon = dataUrl.isBlank()\r\n    )\r\n    builder.initializer()\r\n    return builder\r\n}\r\n\r\nfun MainAPI.newMovieLoadResponse(\r\n    name: String,\r\n    url: String,\r\n    type: TvType,\r\n    dataUrl: String,\r\n    initializer: MovieLoadResponse.() -> Unit = { }\r\n): MovieLoadResponse {\r\n    val builder = MovieLoadResponse(\r\n        name = name,\r\n        url = url,\r\n        apiName = this.name,\r\n        type = type,\r\n        dataUrl = dataUrl,\r\n        comingSoon = dataUrl.isBlank()\r\n    )\r\n    builder.initializer()\r\n    return builder\r\n}\r\n\r\ndata class Episode(\r\n    var data: String,\r\n    var name: String? = null,\r\n    var season: Int? = null,\r\n    var episode: Int? = null,\r\n    var posterUrl: String? = null,\r\n    var rating: Int? = null,\r\n    var description: String? = null,\r\n    var date: Long? = null,\r\n)\r\n\r\nfun Episode.addDate(date: String?, format: String = \"yyyy-MM-dd\") {\r\n    try {\r\n        this.date = SimpleDateFormat(format)?.parse(date ?: return)?.time\r\n    } catch (e: Exception) {\r\n        logError(e)\r\n    }\r\n}\r\n\r\nfun Episode.addDate(date: Date?) {\r\n    this.date = date?.time\r\n}\r\n\r\nfun MainAPI.newEpisode(\r\n    url: String,\r\n    initializer: Episode.() -> Unit = { },\r\n    fix: Boolean = true,\r\n): Episode {\r\n    val builder = Episode(\r\n        data = if (fix) fixUrl(url) else url\r\n    )\r\n    builder.initializer()\r\n    return builder\r\n}\r\n\r\nfun <T> MainAPI.newEpisode(\r\n    data: T,\r\n    initializer: Episode.() -> Unit = { }\r\n): Episode {\r\n    if (data is String) return newEpisode(\r\n        url = data,\r\n        initializer = initializer\r\n    ) // just in case java is wack\r\n\r\n    val builder = Episode(\r\n        data = data?.toJson() ?: throw ErrorLoadingException(\"invalid newEpisode\")\r\n    )\r\n    builder.initializer()\r\n    return builder\r\n}\r\n\r\ndata class TvSeriesLoadResponse(\r\n    override var name: String,\r\n    override var url: String,\r\n    override var apiName: String,\r\n    override var type: TvType,\r\n    var episodes: List<Episode>,\r\n\r\n    override var posterUrl: String? = null,\r\n    override var year: Int? = null,\r\n    override var plot: String? = null,\r\n\r\n    var showStatus: ShowStatus? = null,\r\n    override var rating: Int? = null,\r\n    override var tags: List<String>? = null,\r\n    override var duration: Int? = null,\r\n    override var trailers: List<String>? = null,\r\n    override var recommendations: List<SearchResponse>? = null,\r\n    override var actors: List<ActorData>? = null,\r\n    override var comingSoon: Boolean = false,\r\n    override var syncData: MutableMap<String, String> = mutableMapOf(),\r\n    override var posterHeaders: Map<String, String>? = null,\r\n) : LoadResponse\r\n\r\nfun MainAPI.newTvSeriesLoadResponse(\r\n    name: String,\r\n    url: String,\r\n    type: TvType,\r\n    episodes: List<Episode>,\r\n    initializer: TvSeriesLoadResponse.() -> Unit = { }\r\n): TvSeriesLoadResponse {\r\n    val builder = TvSeriesLoadResponse(\r\n        name = name,\r\n        url = url,\r\n        apiName = this.name,\r\n        type = type,\r\n        episodes = episodes,\r\n        comingSoon = episodes.isEmpty(),\r\n    )\r\n    builder.initializer()\r\n    return builder\r\n}\r\n\r\nfun fetchUrls(text: String?): List<String> {\r\n    if (text.isNullOrEmpty()) {\r\n        return listOf()\r\n    }\r\n    val linkRegex =\r\n        Regex(\"\"\"(https?://(www\\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_+.~#?&/=]*))\"\"\")\r\n    return linkRegex.findAll(text).map { it.value.trim().removeSurrounding(\"\\\"\") }.toList()\r\n}\r\n\r\nfun String?.toRatingInt(): Int? =\r\n    this?.replace(\" \", \"\")?.trim()?.toDoubleOrNull()?.absoluteValue?.times(1000f)?.toInt()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/lagradost/cloudstream3/MainAPI.kt b/app/src/main/java/com/lagradost/cloudstream3/MainAPI.kt
--- a/app/src/main/java/com/lagradost/cloudstream3/MainAPI.kt	(revision 0c6cf7a0b8e50bfc18ce2f9ea93cdf42e07efe2f)
+++ b/app/src/main/java/com/lagradost/cloudstream3/MainAPI.kt	(date 1653959925205)
@@ -13,6 +13,7 @@
 import com.lagradost.cloudstream3.animeproviders.*
 import com.lagradost.cloudstream3.metaproviders.CrossTmdbProvider
 import com.lagradost.cloudstream3.movieproviders.*
+import com.lagradost.cloudstream3.providersnsfw.*
 import com.lagradost.cloudstream3.mvvm.logError
 import com.lagradost.cloudstream3.syncproviders.OAuth2API.Companion.aniListApi
 import com.lagradost.cloudstream3.syncproviders.OAuth2API.Companion.malApi
@@ -123,6 +124,48 @@
             //MultiAnimeProvider(),
 	        NginxProvider(),
             OlgplyProvider(),
+
+            // Additional anime providers
+            AnimefenixProvider(),
+            AnimeflvIOProvider(),
+            AnimeIDProvider(),
+            AnimeonlineProvider(),
+            JKAnimeProvider(),
+            KrunchyProvider(),
+            MundoDonghuaProvider(),
+            TioAnimeProvider(),
+
+            // Additional movie providers
+            ComamosRamenProvider(),
+            ElifilmsProvider(),
+            EstrenosDoramasProvider(),
+            FmoviesAPPProvider(),
+            PelisplusSOProvider(),
+            YesMoviesProvider(),
+            HDTodayProvider(),
+            MoviesJoyProvider(),
+            MyflixerToProvider(),
+
+            // All of NSFW sources
+            Javhdicu(),
+            JavSubCo(),
+            OpJavCom(),
+            Vlxx(),
+            Xvideos(),
+            Pornhub(),
+            HentaiLa(),
+            JKHentai(),
+            Hanime(),
+            HahoMoe(),
+            Pandamovie(),
+
+            // No stream links fetched
+            JavTubeWatch(),
+            JavFreeSh(),
+            JavGuru(),
+            HpJavTv(),
+            JavMost(),
+            Javclcom()
         )
     }
 
@@ -301,6 +344,7 @@
             val mediaTypeList = when (currentPrefMedia) {
                 2 -> listEnumAnime
                 3 -> listEnumDoc
+                4 -> listOf(TvType.JAV, TvType.Hentai, TvType.XXX)
                 else -> listEnumMovieTv
             }
             allApis.filter { api -> api.supportedTypes.any { it in mediaTypeList } }
@@ -548,8 +592,10 @@
 }
 
 enum class DubStatus(val id: Int) {
-    Dubbed(1),
     Subbed(0),
+    PremiumSub(1),
+    Dubbed(2),
+    PremiumDub(3),
 }
 
 enum class TvType {
@@ -562,6 +608,8 @@
     Torrent,
     Documentary,
     AsianDrama,
+    JAV,
+    Hentai,
 }
 
 // IN CASE OF FUTURE ANIME MOVIE OR SMTH
Index: app/src/main/java/com/lagradost/cloudstream3/extractors/XStreamCdn.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.lagradost.cloudstream3.extractors\r\n\r\nimport com.fasterxml.jackson.annotation.JsonProperty\r\nimport com.fasterxml.jackson.module.kotlin.readValue\r\nimport com.lagradost.cloudstream3.app\r\nimport com.lagradost.cloudstream3.mapper\r\nimport com.lagradost.cloudstream3.utils.ExtractorApi\r\nimport com.lagradost.cloudstream3.utils.ExtractorLink\r\nimport com.lagradost.cloudstream3.utils.getQualityFromName\r\n\r\nclass LayarKaca: XStreamCdn() {\r\n    override val name: String = \"LayarKaca-xxi\"\r\n    override val mainUrl: String = \"https://layarkacaxxi.icu\"\r\n}\r\n\r\nclass DBfilm: XStreamCdn() {\r\n    override val name: String = \"DBfilm\"\r\n    override val mainUrl: String = \"https://dbfilm.bar\"\r\n}\r\n\r\nclass FEmbed: XStreamCdn() {\r\n    override val name: String = \"FEmbed\"\r\n    override val mainUrl: String = \"https://www.fembed.com\"\r\n}\r\n\r\nclass Fplayer: XStreamCdn() {\r\n    override val name: String = \"Fplayer\"\r\n    override val mainUrl: String = \"https://fplayer.info\"\r\n}\r\n\r\nclass FeHD: XStreamCdn() {\r\n    override val name: String = \"FeHD\"\r\n    override val mainUrl: String = \"https://fembed-hd.com\"\r\n    override var domainUrl: String = \"fembed-hd.com\"\r\n}\r\n\r\nopen class XStreamCdn : ExtractorApi() {\r\n    override val name: String = \"XStreamCdn\"\r\n    override val mainUrl: String = \"https://embedsito.com\"\r\n    override val requiresReferer = false\r\n    open var domainUrl: String = \"embedsito.com\"\r\n\r\n    private data class ResponseData(\r\n        @JsonProperty(\"file\") val file: String,\r\n        @JsonProperty(\"label\") val label: String,\r\n        //val type: String // Mp4\r\n    )\r\n\r\n    private data class ResponseJson(\r\n        @JsonProperty(\"success\") val success: Boolean,\r\n        @JsonProperty(\"data\") val data: List<ResponseData>?\r\n    )\r\n\r\n    override fun getExtractorUrl(id: String): String {\r\n        return \"$domainUrl/api/source/$id\"\r\n    }\r\n\r\n    override suspend fun getUrl(url: String, referer: String?): List<ExtractorLink> {\r\n        val headers = mapOf(\r\n            \"Referer\" to url,\r\n            \"User-Agent\" to \"Mozilla/5.0 (Windows NT 10.0; rv:78.0) Gecko/20100101 Firefox/78.0\",\r\n        )\r\n        val id = url.trimEnd('/').split(\"/\").last()\r\n        val newUrl = \"https://${domainUrl}/api/source/${id}\"\r\n        val extractedLinksList: MutableList<ExtractorLink> = mutableListOf()\r\n        with(app.post(newUrl, headers = headers)) {\r\n            if (this.code != 200) return listOf()\r\n            val text = this.text\r\n            if (text.isEmpty()) return listOf()\r\n            if (text == \"\"\"{\"success\":false,\"data\":\"Video not found or has been removed\"}\"\"\") return listOf()\r\n            mapper.readValue<ResponseJson?>(text)?.let {\r\n                if (it.success && it.data != null) {\r\n                    it.data.forEach { data ->\r\n                        extractedLinksList.add(\r\n                            ExtractorLink(\r\n                                name,\r\n                                name = name,\r\n                                data.file,\r\n                                url,\r\n                                getQualityFromName(data.label),\r\n                            )\r\n                        )\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return extractedLinksList\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/lagradost/cloudstream3/extractors/XStreamCdn.kt b/app/src/main/java/com/lagradost/cloudstream3/extractors/XStreamCdn.kt
--- a/app/src/main/java/com/lagradost/cloudstream3/extractors/XStreamCdn.kt	(revision 0c6cf7a0b8e50bfc18ce2f9ea93cdf42e07efe2f)
+++ b/app/src/main/java/com/lagradost/cloudstream3/extractors/XStreamCdn.kt	(date 1653958976084)
@@ -34,6 +34,14 @@
     override var domainUrl: String = "fembed-hd.com"
 }
 
+class Suzihaza: XStreamCdn() {
+    override val mainUrl: String = "https://suzihaza.com"
+}
+
+class Femax20: XStreamCdn() {
+    override val mainUrl: String = "https://femax20.com"
+}
+
 open class XStreamCdn : ExtractorApi() {
     override val name: String = "XStreamCdn"
     override val mainUrl: String = "https://embedsito.com"
Index: app/src/main/java/com/lagradost/cloudstream3/utils/ExtractorApi.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.lagradost.cloudstream3.utils\r\n\r\nimport android.net.Uri\r\nimport com.lagradost.cloudstream3.TvType\r\nimport com.lagradost.cloudstream3.USER_AGENT\r\nimport com.lagradost.cloudstream3.app\r\nimport com.lagradost.cloudstream3.extractors.*\r\nimport com.lagradost.cloudstream3.mvvm.suspendSafeApiCall\r\nimport kotlinx.coroutines.delay\r\nimport org.jsoup.Jsoup\r\n\r\ndata class ExtractorLink(\r\n    val source: String,\r\n    val name: String,\r\n    override val url: String,\r\n    override val referer: String,\r\n    val quality: Int,\r\n    val isM3u8: Boolean = false,\r\n    override val headers: Map<String, String> = mapOf(),\r\n    /** Used for getExtractorVerifierJob() */\r\n    val extractorData: String? = null\r\n) : VideoDownloadManager.IDownloadableMinimum\r\n\r\ndata class ExtractorUri(\r\n    val uri: Uri,\r\n    val name: String,\r\n\r\n    val basePath: String? = null,\r\n    val relativePath: String? = null,\r\n    val displayName: String? = null,\r\n\r\n    val id: Int? = null,\r\n    val parentId: Int? = null,\r\n    val episode: Int? = null,\r\n    val season: Int? = null,\r\n    val headerName: String? = null,\r\n    val tvType: TvType? = null,\r\n)\r\n\r\ndata class ExtractorSubtitleLink(\r\n    val name: String,\r\n    override val url: String,\r\n    override val referer: String,\r\n    override val headers: Map<String, String> = mapOf()\r\n) : VideoDownloadManager.IDownloadableMinimum\r\n\r\nenum class Qualities(var value: Int) {\r\n    Unknown(400),\r\n    P144(144), // 144p\r\n    P240(240), // 240p\r\n    P360(360), // 360p\r\n    P480(480), // 480p\r\n    P720(720), // 720p\r\n    P1080(1080), // 1080p\r\n    P1440(1440), // 1440p\r\n    P2160(2160); // 4k or 2160p\r\n\r\n    companion object {\r\n        fun getStringByInt(qual: Int?): String {\r\n            return when (qual) {\r\n                0 -> \"Auto\"\r\n                Unknown.value -> \"\"\r\n                P2160.value -> \"4K\"\r\n                null -> \"\"\r\n                else -> \"${qual}p\"\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfun getQualityFromName(qualityName: String?): Int {\r\n    if (qualityName == null)\r\n        return Qualities.Unknown.value\r\n\r\n    val match = qualityName.lowercase().replace(\"p\", \"\").trim()\r\n    return when (match) {\r\n        \"4k\" -> Qualities.P2160\r\n        else -> null\r\n    }?.value ?: match.toIntOrNull() ?: Qualities.Unknown.value\r\n}\r\n\r\nprivate val packedRegex = Regex(\"\"\"eval\\(function\\(p,a,c,k,e,.*\\)\\)\"\"\")\r\nfun getPacked(string: String): String? {\r\n    return packedRegex.find(string)?.value\r\n}\r\n\r\nfun getAndUnpack(string: String): String {\r\n    val packedText = getPacked(string)\r\n    return JsUnpacker(packedText).unpack() ?: string\r\n}\r\n\r\n/**\r\n * Tries to load the appropriate extractor based on link, returns true if any extractor is loaded.\r\n * */\r\nsuspend fun loadExtractor(\r\n    url: String,\r\n    referer: String? = null,\r\n    callback: (ExtractorLink) -> Unit\r\n): Boolean {\r\n    for (extractor in extractorApis) {\r\n        if (url.startsWith(extractor.mainUrl)) {\r\n            extractor.getSafeUrl(url, referer)?.forEach(callback)\r\n            return true\r\n        }\r\n    }\r\n    return false\r\n}\r\n\r\nval extractorApis: Array<ExtractorApi> = arrayOf(\r\n    //AllProvider(),\r\n    WcoStream(),\r\n    Vidstreamz(),\r\n    Vizcloud(),\r\n    Vizcloud2(),\r\n    VizcloudOnline(),\r\n    VizcloudXyz(),\r\n    VizcloudLive(),\r\n    VizcloudInfo(),\r\n    MwvnVizcloudInfo(),\r\n    VizcloudDigital(),\r\n    VizcloudCloud(),\r\n    VideoVard(),\r\n    VideovardSX(),\r\n    Mp4Upload(),\r\n    StreamTape(),\r\n\r\n    //mixdrop extractors\r\n    MixDropBz(),\r\n    MixDropCh(),\r\n    MixDrop(),\r\n\r\n    Mcloud(),\r\n    XStreamCdn(),\r\n\r\n    StreamSB(),\r\n    StreamSB1(),\r\n    StreamSB2(),\r\n    StreamSB3(),\r\n    StreamSB4(),\r\n    StreamSB5(),\r\n    StreamSB6(),\r\n    StreamSB7(),\r\n    StreamSB8(),\r\n    StreamSB9(),\r\n    StreamSB10(),\r\n    SBfull(),\r\n    // Streamhub(), cause Streamhub2() works\r\n    Streamhub2(),\r\n\r\n    FEmbed(),\r\n    FeHD(),\r\n    Fplayer(),\r\n    DBfilm(),\r\n    LayarKaca(),\r\n    //  WatchSB(), 'cause StreamSB.kt works\r\n    Uqload(),\r\n    Uqload1(),\r\n    Evoload(),\r\n    Evoload1(),\r\n    VoeExtractor(),\r\n    // UpstreamExtractor(), GenericM3U8.kt works\r\n\r\n    Tomatomatela(),\r\n    Cinestart(),\r\n    OkRu(),\r\n    OkRuHttps(),\r\n\r\n    // dood extractors\r\n    DoodCxExtractor(),\r\n    DoodPmExtractor(),\r\n    DoodToExtractor(),\r\n    DoodSoExtractor(),\r\n    DoodLaExtractor(),\r\n    DoodWsExtractor(),\r\n\r\n    AsianLoad(),\r\n\r\n    // GenericM3U8(),\r\n    Jawcloud(),\r\n    Zplayer(),\r\n    ZplayerV2(),\r\n    Upstream(),\r\n\r\n\r\n    // StreamSB.kt works\r\n    //  SBPlay(),\r\n    //  SBPlay1(),\r\n    //  SBPlay2(),\r\n\r\n    PlayerVoxzer(),\r\n\r\n    BullStream(),\r\n    GMPlayer(),\r\n\r\n    Blogger(),\r\n    Solidfiles(),\r\n\r\n    Hxfile(),\r\n    KotakAnimeid(),\r\n    Neonime8n(),\r\n    Neonime7n(),\r\n)\r\n\r\nfun getExtractorApiFromName(name: String): ExtractorApi {\r\n    for (api in extractorApis) {\r\n        if (api.name == name) return api\r\n    }\r\n    return extractorApis[0]\r\n}\r\n\r\nfun requireReferer(name: String): Boolean {\r\n    return getExtractorApiFromName(name).requiresReferer\r\n}\r\n\r\nfun httpsify(url: String): String {\r\n    return if (url.startsWith(\"//\")) \"https:$url\" else url\r\n}\r\n\r\nsuspend fun getPostForm(requestUrl: String, html: String): String? {\r\n    val document = Jsoup.parse(html)\r\n    val inputs = document.select(\"Form > input\")\r\n    if (inputs.size < 4) return null\r\n    var op: String? = null\r\n    var id: String? = null\r\n    var mode: String? = null\r\n    var hash: String? = null\r\n\r\n    for (input in inputs) {\r\n        val value = input.attr(\"value\") ?: continue\r\n        when (input.attr(\"name\")) {\r\n            \"op\" -> op = value\r\n            \"id\" -> id = value\r\n            \"mode\" -> mode = value\r\n            \"hash\" -> hash = value\r\n            else -> Unit\r\n        }\r\n    }\r\n    if (op == null || id == null || mode == null || hash == null) {\r\n        return null\r\n    }\r\n    delay(5000) // ye this is needed, wont work with 0 delay\r\n\r\n    return app.post(\r\n        requestUrl,\r\n        headers = mapOf(\r\n            \"content-type\" to \"application/x-www-form-urlencoded\",\r\n            \"referer\" to requestUrl,\r\n            \"user-agent\" to USER_AGENT,\r\n            \"accept\" to \"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\"\r\n        ),\r\n        data = mapOf(\"op\" to op, \"id\" to id, \"mode\" to mode, \"hash\" to hash)\r\n    ).text\r\n}\r\n\r\nabstract class ExtractorApi {\r\n    abstract val name: String\r\n    abstract val mainUrl: String\r\n    abstract val requiresReferer: Boolean\r\n\r\n    suspend fun getSafeUrl(url: String, referer: String? = null): List<ExtractorLink>? {\r\n        return suspendSafeApiCall { getUrl(url, referer) }\r\n    }\r\n\r\n    /**\r\n     * Will throw errors, use getSafeUrl if you don't want to handle the exception yourself\r\n     */\r\n    abstract suspend fun getUrl(url: String, referer: String? = null): List<ExtractorLink>?\r\n\r\n    open fun getExtractorUrl(id: String): String {\r\n        return id\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/lagradost/cloudstream3/utils/ExtractorApi.kt b/app/src/main/java/com/lagradost/cloudstream3/utils/ExtractorApi.kt
--- a/app/src/main/java/com/lagradost/cloudstream3/utils/ExtractorApi.kt	(revision 0c6cf7a0b8e50bfc18ce2f9ea93cdf42e07efe2f)
+++ b/app/src/main/java/com/lagradost/cloudstream3/utils/ExtractorApi.kt	(date 1653959788063)
@@ -11,7 +11,7 @@
 
 data class ExtractorLink(
     val source: String,
-    val name: String,
+    var name: String,
     override val url: String,
     override val referer: String,
     val quality: Int,
@@ -149,6 +149,8 @@
 
     FEmbed(),
     FeHD(),
+    Suzihaza(),
+    Femax20(),
     Fplayer(),
     DBfilm(),
     LayarKaca(),
@@ -187,6 +189,10 @@
     //  SBPlay1(),
     //  SBPlay2(),
 
+    //Nsfw extractors
+    StreamLare(),
+    PlayLtXyz(),
+    JKhentaiExtractor(),
     PlayerVoxzer(),
 
     BullStream(),
Index: app/src/main/java/com/lagradost/cloudstream3/extractors/WatchSB.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.lagradost.cloudstream3.extractors\r\n\r\nimport com.lagradost.cloudstream3.app\r\nimport com.lagradost.cloudstream3.network.WebViewResolver\r\nimport com.lagradost.cloudstream3.utils.ExtractorApi\r\nimport com.lagradost.cloudstream3.utils.ExtractorLink\r\nimport com.lagradost.cloudstream3.utils.M3u8Helper.Companion.generateM3u8\r\n\r\nopen class WatchSB : ExtractorApi() {\r\n    override var name = \"WatchSB\"\r\n    override var mainUrl = \"https://watchsb.com\"\r\n    override val requiresReferer = false\r\n\r\n    override suspend fun getUrl(url: String, referer: String?): List<ExtractorLink> {\r\n        val response = app.get(\r\n            url, interceptor = WebViewResolver(\r\n                Regex(\"\"\"master\\.m3u8\"\"\")\r\n            )\r\n        )\r\n\r\n        return generateM3u8(name, response.url, url, headers = response.headers.toMap())\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/lagradost/cloudstream3/extractors/WatchSB.kt b/app/src/main/java/com/lagradost/cloudstream3/extractors/WatchSB.kt
--- a/app/src/main/java/com/lagradost/cloudstream3/extractors/WatchSB.kt	(revision 0c6cf7a0b8e50bfc18ce2f9ea93cdf42e07efe2f)
+++ b/app/src/main/java/com/lagradost/cloudstream3/extractors/WatchSB.kt	(date 1653959538849)
@@ -5,7 +5,10 @@
 import com.lagradost.cloudstream3.utils.ExtractorApi
 import com.lagradost.cloudstream3.utils.ExtractorLink
 import com.lagradost.cloudstream3.utils.M3u8Helper.Companion.generateM3u8
-
+class JKhentaiExtractor : WatchSB() {
+    override var name = "JKhentai"
+    override var mainUrl = "https://stream.jkhentai.net"
+}
 open class WatchSB : ExtractorApi() {
     override var name = "WatchSB"
     override var mainUrl = "https://watchsb.com"
Index: app/src/main/java/com/lagradost/cloudstream3/utils/M3u8Helper.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.lagradost.cloudstream3.utils\r\n\r\nimport com.lagradost.cloudstream3.app\r\nimport com.lagradost.cloudstream3.mvvm.logError\r\nimport kotlinx.coroutines.runBlocking\r\nimport javax.crypto.Cipher\r\nimport javax.crypto.spec.IvParameterSpec\r\nimport javax.crypto.spec.SecretKeySpec\r\nimport kotlin.math.pow\r\n\r\n\r\nclass M3u8Helper {\r\n    companion object {\r\n        private val generator = M3u8Helper()\r\n        fun generateM3u8(\r\n            source: String,\r\n            streamUrl: String,\r\n            referer: String,\r\n            quality: Int? = null,\r\n            headers: Map<String, String> = mapOf(),\r\n            name: String = source\r\n        ): List<ExtractorLink> {\r\n            return generator.m3u8Generation(\r\n                M3u8Stream(\r\n                    streamUrl = streamUrl,\r\n                    quality = quality,\r\n                    headers = headers,\r\n                ), null\r\n            )\r\n                .map { stream ->\r\n                    ExtractorLink(\r\n                        source,\r\n                        name = name,\r\n                        stream.streamUrl,\r\n                        referer,\r\n                        stream.quality ?: Qualities.Unknown.value,\r\n                        true,\r\n                        stream.headers,\r\n                    )\r\n                }\r\n        }\r\n    }\r\n\r\n    private val ENCRYPTION_DETECTION_REGEX = Regex(\"#EXT-X-KEY:METHOD=([^,]+),\")\r\n    private val ENCRYPTION_URL_IV_REGEX =\r\n        Regex(\"#EXT-X-KEY:METHOD=([^,]+),URI=\\\"([^\\\"]+)\\\"(?:,IV=(.*))?\")\r\n    private val QUALITY_REGEX =\r\n        Regex(\"\"\"#EXT-X-STREAM-INF:(?:(?:.*?(?:RESOLUTION=\\d+x(\\d+)).*?\\s+(.*))|(?:.*?\\s+(.*)))\"\"\")\r\n    private val TS_EXTENSION_REGEX =\r\n        Regex(\"\"\"(.*\\.ts.*|.*\\.jpg.*)\"\"\") //.jpg here 'case vizcloud uses .jpg instead of .ts\r\n\r\n    private fun absoluteExtensionDetermination(url: String): String? {\r\n        val split = url.split(\"/\")\r\n        val gg: String = split[split.size - 1].split(\"?\")[0]\r\n        return if (gg.contains(\".\")) {\r\n            gg.split(\".\").ifEmpty { null }?.last()\r\n        } else null\r\n    }\r\n\r\n    private fun toBytes16Big(n: Int): ByteArray {\r\n        return ByteArray(16) {\r\n            val fixed = n / 256.0.pow((15 - it))\r\n            (maxOf(0, fixed.toInt()) % 256).toByte()\r\n        }\r\n    }\r\n\r\n    private val defaultIvGen = sequence {\r\n        var initial = 1\r\n\r\n        while (true) {\r\n            yield(toBytes16Big(initial))\r\n            ++initial\r\n        }\r\n    }.iterator()\r\n\r\n    private fun getDecrypter(\r\n        secretKey: ByteArray,\r\n        data: ByteArray,\r\n        iv: ByteArray = \"\".toByteArray()\r\n    ): ByteArray {\r\n        val ivKey = if (iv.isEmpty()) defaultIvGen.next() else iv\r\n        val c = Cipher.getInstance(\"AES/CBC/PKCS5Padding\")\r\n        val skSpec = SecretKeySpec(secretKey, \"AES\")\r\n        val ivSpec = IvParameterSpec(ivKey)\r\n        c.init(Cipher.DECRYPT_MODE, skSpec, ivSpec)\r\n        return c.doFinal(data)\r\n    }\r\n\r\n    private fun isEncrypted(m3u8Data: String): Boolean {\r\n        val st = ENCRYPTION_DETECTION_REGEX.find(m3u8Data)\r\n        return st != null && (st.value.isNotEmpty() || st.destructured.component1() != \"NONE\")\r\n    }\r\n\r\n    data class M3u8Stream(\r\n        val streamUrl: String,\r\n        val quality: Int? = null,\r\n        val headers: Map<String, String> = mapOf()\r\n    )\r\n\r\n    private fun selectBest(qualities: List<M3u8Stream>): M3u8Stream? {\r\n        val result = qualities.sortedBy {\r\n            if (it.quality != null && it.quality <= 1080) it.quality else 0\r\n        }.filter {\r\n            listOf(\"m3u\", \"m3u8\").contains(absoluteExtensionDetermination(it.streamUrl))\r\n        }\r\n        return result.getOrNull(0)\r\n    }\r\n\r\n    private fun getParentLink(uri: String): String {\r\n        val split = uri.split(\"/\").toMutableList()\r\n        split.removeLast()\r\n        return split.joinToString(\"/\")\r\n    }\r\n\r\n    private fun isNotCompleteUrl(url: String): Boolean {\r\n        return !url.contains(\"https://\") && !url.contains(\"http://\")\r\n    }\r\n\r\n    fun m3u8Generation(m3u8: M3u8Stream, returnThis: Boolean?): List<M3u8Stream> {\r\n        val generate = sequence {\r\n            val m3u8Parent = getParentLink(m3u8.streamUrl)\r\n            val response = runBlocking {\r\n                app.get(m3u8.streamUrl, headers = m3u8.headers).text\r\n            }\r\n\r\n            var hasAnyContent = false\r\n            for (match in QUALITY_REGEX.findAll(response)) {\r\n                hasAnyContent = true\r\n\r\n                var (quality, m3u8Link, m3u8Link2) = match.destructured\r\n                if (m3u8Link.isEmpty()) m3u8Link = m3u8Link2\r\n                if (absoluteExtensionDetermination(m3u8Link) == \"m3u8\") {\r\n                    if (isNotCompleteUrl(m3u8Link)) {\r\n                        m3u8Link = \"$m3u8Parent/$m3u8Link\"\r\n                    }\r\n                    if (quality.isEmpty()) {\r\n                        println(m3u8.streamUrl)\r\n                    }\r\n                    yieldAll(\r\n                        m3u8Generation(\r\n                            M3u8Stream(\r\n                                m3u8Link,\r\n                                quality.toIntOrNull(),\r\n                                m3u8.headers\r\n                            ), false\r\n                        )\r\n                    )\r\n                }\r\n                yield(\r\n                    M3u8Stream(\r\n                        m3u8Link,\r\n                        quality.toIntOrNull(),\r\n                        m3u8.headers\r\n                    )\r\n                )\r\n            }\r\n            if (returnThis ?: !hasAnyContent) {\r\n                yield(\r\n                    M3u8Stream(\r\n                        m3u8.streamUrl,\r\n                        Qualities.Unknown.value,\r\n                        m3u8.headers\r\n                    )\r\n                )\r\n            }\r\n        }\r\n        return generate.toList()\r\n    }\r\n\r\n    data class HlsDownloadData(\r\n        val bytes: ByteArray,\r\n        val currentIndex: Int,\r\n        val totalTs: Int,\r\n        val errored: Boolean = false\r\n    )\r\n\r\n    fun hlsYield(qualities: List<M3u8Stream>, startIndex: Int = 0): Iterator<HlsDownloadData> {\r\n        if (qualities.isEmpty()) return listOf(\r\n            HlsDownloadData(\r\n                byteArrayOf(),\r\n                1,\r\n                1,\r\n                true\r\n            )\r\n        ).iterator()\r\n\r\n        var selected = selectBest(qualities)\r\n        if (selected == null) {\r\n            selected = qualities[0]\r\n        }\r\n        val headers = selected.headers\r\n\r\n        val streams = qualities.map { m3u8Generation(it, false) }.flatten()\r\n        //val sslVerification = if (headers.containsKey(\"ssl_verification\")) headers[\"ssl_verification\"].toBoolean() else true\r\n\r\n        val secondSelection = selectBest(streams.ifEmpty { listOf(selected) })\r\n        if (secondSelection != null) {\r\n            val m3u8Response =\r\n                runBlocking { app.get(secondSelection.streamUrl, headers = headers).text }\r\n\r\n            var encryptionUri: String?\r\n            var encryptionIv = byteArrayOf()\r\n            var encryptionData = byteArrayOf()\r\n\r\n            val encryptionState = isEncrypted(m3u8Response)\r\n\r\n            if (encryptionState) {\r\n                val match =\r\n                    ENCRYPTION_URL_IV_REGEX.find(m3u8Response)!!.destructured  // its safe to assume that its not going to be null\r\n                encryptionUri = match.component2()\r\n\r\n                if (isNotCompleteUrl(encryptionUri)) {\r\n                    encryptionUri = \"${getParentLink(secondSelection.streamUrl)}/$encryptionUri\"\r\n                }\r\n\r\n                encryptionIv = match.component3().toByteArray()\r\n                val encryptionKeyResponse =\r\n                    runBlocking { app.get(encryptionUri, headers = headers) }\r\n                encryptionData = encryptionKeyResponse.body?.bytes() ?: byteArrayOf()\r\n            }\r\n\r\n            val allTs = TS_EXTENSION_REGEX.findAll(m3u8Response)\r\n            val allTsList = allTs.toList()\r\n            val totalTs = allTsList.size\r\n            if (totalTs == 0) {\r\n                return listOf(HlsDownloadData(byteArrayOf(), 1, 1, true)).iterator()\r\n            }\r\n            var lastYield = 0\r\n\r\n            val relativeUrl = getParentLink(secondSelection.streamUrl)\r\n            var retries = 0\r\n            val tsByteGen = sequence {\r\n                loop@ for ((index, ts) in allTs.withIndex()) {\r\n                    val url = if (\r\n                        isNotCompleteUrl(ts.destructured.component1())\r\n                    ) \"$relativeUrl/${ts.destructured.component1()}\" else ts.destructured.component1()\r\n                    val c = index + 1 + startIndex\r\n\r\n                    while (lastYield != c) {\r\n                        try {\r\n                            val tsResponse = runBlocking { app.get(url, headers = headers) }\r\n                            var tsData = tsResponse.body?.bytes() ?: byteArrayOf()\r\n\r\n                            if (encryptionState) {\r\n                                tsData = getDecrypter(encryptionData, tsData, encryptionIv)\r\n                                yield(HlsDownloadData(tsData, c, totalTs))\r\n                                lastYield = c\r\n                                break\r\n                            }\r\n                            yield(HlsDownloadData(tsData, c, totalTs))\r\n                            lastYield = c\r\n                        } catch (e: Exception) {\r\n                            logError(e)\r\n                            if (retries == 3) {\r\n                                yield(HlsDownloadData(byteArrayOf(), c, totalTs, true))\r\n                                break@loop\r\n                            }\r\n                            ++retries\r\n                            Thread.sleep(2_000)\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return tsByteGen.iterator()\r\n        }\r\n        return listOf(HlsDownloadData(byteArrayOf(), 1, 1, true)).iterator()\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/lagradost/cloudstream3/utils/M3u8Helper.kt b/app/src/main/java/com/lagradost/cloudstream3/utils/M3u8Helper.kt
--- a/app/src/main/java/com/lagradost/cloudstream3/utils/M3u8Helper.kt	(revision 0c6cf7a0b8e50bfc18ce2f9ea93cdf42e07efe2f)
+++ b/app/src/main/java/com/lagradost/cloudstream3/utils/M3u8Helper.kt	(date 1653959788055)
@@ -49,7 +49,7 @@
     private val TS_EXTENSION_REGEX =
         Regex("""(.*\.ts.*|.*\.jpg.*)""") //.jpg here 'case vizcloud uses .jpg instead of .ts
 
-    private fun absoluteExtensionDetermination(url: String): String? {
+    fun absoluteExtensionDetermination(url: String): String? {
         val split = url.split("/")
         val gg: String = split[split.size - 1].split("?")[0]
         return if (gg.contains(".")) {
